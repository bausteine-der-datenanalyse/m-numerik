{
  "hash": "829b8afdfd8a7c28a1575e4023ac41a9",
  "result": {
    "engine": "jupyter",
    "markdown": "## Integration\n\nDie Bildung von Integralen findet beispielsweise bei der Bestimmung von Flächeninhalten oder von Gesamtkräften Anwendung. Formal wird das bestimmte Integral $\\mathsf{I}$ der Funktion $\\mathsf{f(x)}$ auf dem Intervall $\\mathsf{x \\in [a,b]}$ wie folgt dargestellt.\n\n$$ \\mathsf{I = \\int_a^b f(x)\\ dx} $$\n\nIm Allgemeinen kann das Integral nicht analytisch gelöst werden, da die Stammfunktion $\\mathsf{F(x)}$ nicht leicht zu bestimmen ist. In solchen Fällen können numersiche Verfahren eingesetzt werden um den Integralwert zu approximieren. Die numerische Integration wird oft auch als numersiche Quadratur bezeichnet.\n\nDieses Kapitel bietet eine kurze Übersicht von numerischen Integrationsmethoden: \n\n* Ober- und Untersumme\n* Quadratur\n* Monte-Carlo\n\n### Ober- und Untersumme\n\n::: {.cell tags='[\"hide-input\"]' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n\nEine der grundlegendsten Arten Integrale von Funktionen zu bestimmen sind die \n[Ober- und Untersumme](https://de.wikipedia.org/wiki/Riemannsches_Integral). \nSie nähern den Integralwert durch eine Abschätzung nach oben bzw. unten an. \nMit einer steigenden Anzahl von Stützstellen, d.h. Positionen an welchen die \nFunktion ausgewertet wird, konvergieren beide Abschätzungen gegen den \nIntegralwert.\n\n## Definition\n\nFür die Bildung der Ober- und Untersumme, werden gleichmäßig verteilte \nStützstellen auf dem Intervall $\\mathsf{[a,b]}$ benötigt. Werden $\\mathsf{n+1}$ \nStützstellen gewählt, so gilt:\n\n$$ a = x_0 < x_1 < \\cdots < x_n = b $$\n\nDer Abstand der Stützstellen beträgt $\\mathsf{\\Delta x = (b-a)/(n-1)}$. Auf \njedem der $\\mathsf{n}$ Teilintervalle $\\mathsf{[x_{i-1}, x_{i}]}$ wird nun der \nmaximale bzw. minimale Wert der Funktion $\\mathsf{f(x)}$ bestimmt und als \n$\\mathsf{O_i}$ bzw. $\\mathsf{U_i}$ definiert.\n\n$$ \\mathsf{O_i = \\max\\left( f(x) | x \\in [x_{i-1}, x_{i}] \\right)} $$\n$$ \\mathsf{U_i = \\min\\left( f(x) | x \\in [x_{i-1}, x_{i}] \\right)} $$\n\nDie gesuchte Approximation des Integrals ist die Summe der $\\mathsf{O_i}$ \nbzw. $\\mathsf{U_i}$ mal der Breite des Teilintervalls, hier $\\mathsf{\\Delta x}$:\n\n$$ \\sum_{i=1}^n \\Delta x U_i \\lesssim I \\lesssim \\sum_{i=1}^n \\Delta x O_i $$\n\n## Beispiel\n\nBeispielhaft soll folgendes Integral bestimmt werden\n\n$$ \\mathsf{I = \\int_0^2\\sin(3x) + 2x \\ dx} $$\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n```\n:::\n\n\nAls erstes werden die Stützstellen gleichmäßig im Intervall $\\mathsf{[0,2]}$ verteilt.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n```\n:::\n\n\nDie beiden Summen benötigen die Extremwerte der zu integrierenden Funktion in \nden Teilintervallen. Diese werden mit Hilfe einer Funktionsauswertung auf dem \nTeilintervall bestimmt. Für die nachfolgende Visualisierung hat die Menge der \nSummen ebenfalls $\\mathsf{n}$ Elemente.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\noben = np.zeros(n)\nunten = np.zeros(n)\n\nfor i in range(len(oben)-1): \n    cx = np.linspace(xi[i], xi[i+1], 50)\n    cy = fkt(cx)\n    oben[i+1] = np.max(cy)\n    unten[i+1] = np.min(cy)\n```\n:::\n\n\nDie ersten Elemente der beiden Summenlisten werden auf die ersten Funktionswerte \ngesetzt, dies dient nur der folgenden Darstellung.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\noben[0] = yi[0]\nunten[0] = yi[0]\n```\n:::\n\n\nVisualisierung der einzelnen Funktionen.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3', zorder=3)\nplt.plot(xi, oben, drawstyle='steps-pre', label='Obersumme')\nplt.plot(xi, unten, drawstyle='steps-pre', label='Untersumme')\n\nplt.vlines(xi, ymin=unten, ymax=oben, color='C1', alpha=0.6)\nplt.vlines(xi, ymin=0, ymax=unten, color='C2', alpha=0.6)\n\nplt.xlabel('x')\nplt.ylabel('y')\n\nplt.grid()\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-7-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDas obige Verfahren kann nun in einer Funktion zusammengefasst werden, welche \ndie Summen der beiden Folgen zurückgibt.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef ou_summe(n, a=0, b=2):\n    xi = np.linspace(a, b, n)\n    yi = fkt(xi)\n    dx = xi[1] - xi[0]\n    \n    sum_oben = 0\n    sum_unten = 0\n    \n    for i in range(n-1): \n        cx = np.linspace(xi[i], xi[i+1], 50)\n        cy = fkt(cx)\n        oben = np.max(cy)\n        unten = np.min(cy)\n        sum_oben += dx * oben\n        sum_unten += dx * unten\n    \n    return sum_oben, sum_unten\n```\n:::\n\n\nFür eine systematische Untersuchung des Konvergenzverhaltens, wird die \nIntegrationsfunktion für verschiedene Anzahlen von Stützstellen aufgerufen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nn_max = 100\nns = np.arange(2, n_max, 1, dtype=int)\nos = np.zeros(len(ns))\nus = np.zeros(len(ns))\n\n\nfor i, n in enumerate(ns):\n    o, u = ou_summe(n)\n    os[i] = o\n    us[i] = u\n```\n:::\n\n\nDie graphische Darstellung der beiden Summen zeigt eine kontinuierliche \nAnnäherung dieser.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nplt.plot(ns, os, label='Obersumme')\nplt.plot(ns, us, label='Untersumme')\n\nplt.axhline(y=I_exakt, color='C3', alpha=0.3)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Integralwert')\n\nplt.grid()\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-10-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDies wird insbesondere deutlich, wenn die Differenz der beiden Summen \naufgetragen wird. Mit einer logarithmischen Darstellung kann die kontinuierliche \nAnnäherung auch quantitativ abgelesen werden.\n\n::: {.cell tags='[]' execution_count=10}\n``` {.python .cell-code}\nplt.plot(ns, os-us)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz Ober- und Untersumme')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-11-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n## Interpolation\n\n\n\nBei der Bildung der Ober- und Untersumme wurde die zu integrierende Funktion durch einen konstanten Wert in den Teilintervallen zwischen den Stützstellen angenähert. Eine genauere Berechnung des Integrals kann durch eine bessere Interpolation erfolgen. Dazu eignen sich  Polynome, da diese leicht zu Integrieren sind.   \n\n### Trapezregel\n\nDie Trapezregel beruht auf der Annäherung der zu integrierenden Funktion durch Geraden, d.h. Polynome vom Grad 1, auf den Teilintervallen. Die Approximation des Integralwertes ergibt sich entsprechend aus den Flächeninhalten der so entstandenen Trapeze.\n\nWie im vorhergehenden Kapitel wird das Verfahren anhand folgender Funktion demonstriert\n\n$$ \\mathsf{I = \\int_0^2\\sin(3x) + 2x \\ dx} $$\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n```\n:::\n\n\nBildung der Stützpunkte:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n```\n:::\n\n\nZunächst erfolgt noch die Visualisierung des Verfahrens.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3')\nplt.plot(xi, yi, label='Approximation', c='C1')\n\nplt.vlines(xi, ymin=0, ymax=yi, color='C1', alpha=0.3)\n\nplt.grid()\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-15-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDie Integration selbst kann mittels der [Funktion `scipy.integrate.trapezoid`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.trapezoid.html#scipy.integrate.trapezoid) ausgeführt werden.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nres = scipy.integrate.trapezoid(yi, xi)\nprint(f\"Integralwert mit {n} Stützstellen: {res:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntegralwert mit 5 Stützstellen: 4.0107\n```\n:::\n:::\n\n\nDer so ermittelte Wert nähert sich dem exakten Wert mit zunehmender Anzahl der Stützstellen.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nn_max = 50\nns = np.arange(2, n_max, 1, dtype=int)\ntr = np.zeros(len(ns))\n\nfor i, n in enumerate(ns):\n    xi = np.linspace(0, 2, n)\n    yi = fkt(xi)\n    tr[i] = scipy.integrate.trapezoid(yi, xi)\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nplt.plot(ns, tr)\nplt.axhline(y=I_exakt, color='C3', alpha=0.3)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Integralwert')\n\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-18-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nplt.plot(ns, np.abs(tr-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-19-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n### Simpsonregel\n\nDie Verwendung eines Polynoms vom zweiten Grad führt zur Simpsonregel. \nHierzu wird die Funktion an einem Zwischenwert, mittig im Teilintervall, \nausgewertet und zusammen mit den Werten an den Stützstellen zur Bestimmung der \nPolynomkoeffizienten verwendet.\n\nAnhand des obigen Beispiels wird die Simpsonregel visuell demonstriert.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3')\n\n# Bestimmung und Plotten der Polynome\nfor i in range(n-1):\n    dx = xi[i+1] - xi[i]\n    cx = (xi[i] + xi[i+1]) / 2\n    cy = fkt(cx)\n\n    P = np.polyfit([xi[i], cx, xi[i+1]], [yi[i], cy, yi[i+1]], 2)\n    \n    Px = np.linspace(xi[i], xi[i+1], 20)\n    Py = np.polyval(P, Px)\n    \n    label=None\n    if i==0: \n        label='Approximation'\n    \n    plt.plot(Px, Py, color='C1', label=label)\n\nplt.vlines(xi, ymin=0, ymax=yi, color='C1', alpha=0.3)\n\nplt.grid()\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-21-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDie Simpsonregel ist bereits in der [Funktion `scipy.integrate.simpson`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simpson.html#scipy.integrate.simpson) implementiert. Im Folgenden wird nur die Differenz zur Trapezregel demonstriert.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nn_max = 50\nns = np.arange(3, n_max, 2, dtype=int)\nsi = np.zeros(len(ns))\ntr = np.zeros(len(ns))\n\nfor i, n in enumerate(ns):\n    xi = np.linspace(0, 2, n)\n    yi = fkt(xi)\n    si[i] = scipy.integrate.simpson(yi, xi)\n    tr[i] = scipy.integrate.trapezoid(yi, xi)\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=22}\n``` {.python .cell-code}\nplt.plot(ns, np.abs(tr-I_exakt), label='Trapezregel')\nplt.plot(ns, np.abs(si-I_exakt), label='Simpsonregel')\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.legend()\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-23-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n## Monte-Carlo\n\n\n\nEin ganz anderer Ansatz zur Integration wird mit dem \n[Monte-Carlo-Ansatz](https://de.wikipedia.org/wiki/Monte-Carlo-Algorithmus) \nverfolgt. Hierbei werden Zufallspunkte $\\mathsf{x_i}$ innerhalb der gesuchten \nIntegralbereichs generiert. Der Mittelwert der dazugehörigen Summe der \nFunktionswerte $\\mathsf{f(x_i)}$ nähert das Integral an. Insbesondere für eine \nkleine Anzahl von Zufallswerten kann das Ergebnis deutlich vom exakten Wert \nabweichen. Der Vorteil des Verfahrens wird bei hochdimensionalen Integralen \ndeutlich.\n\nFür $\\mathsf{n \\gg 1}$ zufällige Stützstellen $\\mathsf{x_i \\in [a, b]}$ gilt \nfolgende Näherung\n\n$$\\mathsf{I = \\int_a^b f(x)\\ dx \\approx \\frac{b-a}{n}\\sum_{i=1}^n f(x_i)} $$\n\nFür das Beispiel aus den vorhergehenden Kapiteln gilt\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nn = 2000\nxi = np.random.random(n) * 2\nyi = fkt(xi)\nI = 2 * 1/n * np.sum(yi)\nprint(f\"Integralwert für {n} Stützstellen: {I:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntegralwert für 2000 Stützstellen: 3.9620\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nn_max = 50000\ndn = 250\nns = np.arange(dn, n_max, dn, dtype=int)\nmc = np.zeros(len(ns))\n\nxi = np.zeros(n_max)\n\nfor i, n in enumerate(ns):\n    xi[n-dn:n] = np.random.random(dn) * 2\n    yi = fkt(xi[:n])\n    mc[i] = 2 * 1/n * np.sum(yi)\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nplt.plot(ns, np.abs(mc-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-28-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nAlternativ kann auch das Flächenverhältnis zwischen der zu integrierenden \nFunktion und einer Referenzfläche $\\mathsf{A_r}$ gebildet werden. Hierzu \nwerden $\\mathsf{n}$ Zufallszahlenpaare $\\mathsf{(x_i, y_i)}$ generiert und \ngezählt wieviele davon in der gesuchten Fläche liegen. Die Annahme ist, dass \nsich beide Verhältnisse für große $\\mathsf{n}$ annähern. Im einfachsten Fall, \nwenn $\\mathsf{f(x) \\ge 0}$, gilt folgende Abschätzung\n\n$$\\mathsf {I \\approx \\frac{A_r \\cdot \\left|\\left\\{y_i \\ |\\  y_i < f(x_i)\\right\\}\\right|}{n}} $$\n\nIm obigen Beispiel kann die Fläche $\\mathsf{[0, 2] \\times [0, 4] = 8}$ als \nReferenzfläche verwendet werden.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nn = 2000\nxi = np.random.random(n) * 2\nyi = np.random.random(n) * 4\n\nz = np.sum(yi < fkt(xi))\n\nI = z / n * 8\nprint(f\"Integralwert für {n} Stützstellen: {I}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntegralwert für 2000 Stützstellen: 4.044\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nn_max = 50000\ndn = 250\nns = np.arange(dn, n_max, dn, dtype=int)\nmc = np.zeros(len(ns))\n\nxi = np.zeros(n_max)\nyi = np.zeros(n_max)\n\nfor i, n in enumerate(ns):\n    xi[n-dn:n] = np.random.random(dn) * 2\n    yi[n-dn:n] = np.random.random(dn) * 4\n    z = np.sum(yi[:n] < fkt(xi[:n]))\n    mc[i] = z / n * 8\n```\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nplt.plot(ns, np.abs(mc-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_integrale_files/figure-pdf/cell-31-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "intro_integrale_files/figure-pdf"
    ],
    "filters": []
  }
}